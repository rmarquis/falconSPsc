///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

#include "vu2.h"
#include "vu_priv.h"
#include <windows.h> // JPO Needed for CTD checks

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// VuListIterator
//-----------------------------------------------------------------------------

VuListIterator::VuListIterator (VuLinkedList* coll) : VuIterator(coll)
{
	curr_ = vuTailNode;
	vuCollectionManager->Register(this);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

VuListIterator::~VuListIterator()
{
    assert(FALSE == F4IsBadReadPtr(vuCollectionManager, sizeof *vuCollectionManager));
	vuCollectionManager->DeRegister(this);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

VuEntity *VuListIterator::GetFirst (VuFilter* filter)
{
	if (collection_)
	{
	    assert(FALSE == F4IsBadReadPtr(collection_, sizeof *collection_));
		if (filter)
		{
			curr_ = ((VuLinkedList *)collection_)->head_;

			if (curr_->entity_ == 0)
			{
				return curr_->entity_;
			}

			if
			(
				(curr_->entity_->VuState() != VU_MEM_DELETED) &&
				(filter->Test(curr_->entity_))
			)
			{
				return curr_->entity_;
			} 
			else
			{
				return GetNext(filter);
			}
		} 
		else
		{
			return GetFirst();
		}
	}

	return 0;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

VuEntity *VuListIterator::GetNext (VuFilter *filter)
{
	if (filter)
	{
		for (curr_ = curr_->next_; curr_->entity_; curr_ = curr_->next_)
		{ 
			if ((curr_->entity_->VuState() != VU_MEM_DELETED) && (filter->Test(curr_->entity_)))
			{
				return curr_->entity_;
			}
		}

		// reached end of list
		return 0;
	} 
	else
	{
		return GetNext();
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

VuEntity *VuListIterator::CurrEnt()
{
	return curr_->entity_;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

VU_BOOL VuListIterator::IsReferenced (VuEntity* ent)
{
// 2002-02-04 MODIFIED BY S.G. If ent is false, then it can't be a valid entity, right? That's what I think too :-)
//	if (curr_->entity_ == ent)
	if (ent && curr_->entity_ == ent)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

VU_ERRCODE VuListIterator::Cleanup()
{
	curr_ = vuTailNode;

	return VU_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

